{"message":"unresolved import `spin`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nPaths in `use` statements are relative to the crate root. To import items\nrelative to the current and parent modules, use the `self::` and `super::`\nprefixes, respectively. Also verify that you didn't misspell the import\nname and that the import exists in the module from where you tried to\nimport it. Example:\n\n```\nuse self::something::Foo; // ok!\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nOr, if you tried to use a module from an external crate, you may have missed\nthe `extern crate` declaration (which is usually placed in the crate root):\n\n```\nextern crate core; // Required to use the `core` crate\n\nuse core::any;\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/memory/frame/allocator.rs","byte_start":255,"byte_end":259,"line_start":9,"line_end":9,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use spin::Mutex;","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a similar path exists","code":null,"level":"help","spans":[{"file_name":"src/memory/frame/allocator.rs","byte_start":255,"byte_end":259,"line_start":9,"line_end":9,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use spin::Mutex;","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":"buddy_system_allocator::spin","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `spin`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/memory/frame/allocator.rs:9:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse spin::Mutex;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a similar path exists: `buddy_system_allocator::spin`\u001b[0m\n\n"}
{"message":"unused import: `scause::Scause`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/interrupt/context.rs","byte_start":40,"byte_end":54,"line_start":1,"line_end":1,"column_start":41,"column_end":55,"is_primary":true,"text":[{"text":"use riscv::register::{sstatus::Sstatus, scause::Scause};","highlight_start":41,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/interrupt/context.rs","byte_start":38,"byte_end":54,"line_start":1,"line_end":1,"column_start":39,"column_end":55,"is_primary":true,"text":[{"text":"use riscv::register::{sstatus::Sstatus, scause::Scause};","highlight_start":39,"highlight_end":55}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `scause::Scause`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/interrupt/context.rs:1:41\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse riscv::register::{sstatus::Sstatus, scause::Scause};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"no method named `lock` found for struct `memory::frame::allocator::FRAME_ALLOCATOR` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/saduj/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/lazy_static-1.4.0/src/lib.rs","byte_start":4662,"byte_end":5208,"line_start":159,"line_end":173,"column_start":48,"column_end":50,"is_primary":false,"text":[{"text":"        $($vis)* struct $N {__private_field: ()}","highlight_start":48,"highlight_end":49},{"text":"        #[doc(hidden)]","highlight_start":1,"highlight_end":23},{"text":"        $($vis)* static $N: $N = $N {__private_field: ()};","highlight_start":1,"highlight_end":59},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    () => ()","highlight_start":1,"highlight_end":13},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[macro_export(local_inner_macros)]","highlight_start":1,"highlight_end":36},{"text":"macro_rules! lazy_static {","highlight_start":1,"highlight_end":27},{"text":"    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":78},{"text":"        // use `()` to explicitly forward the information about private items","highlight_start":1,"highlight_end":78},{"text":"        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":82},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":82},{"text":"        __lazy_static_internal!($(#[$attr])* (pub) static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":50}],"label":"method `lock` not found for this","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/memory/frame/allocator.rs","byte_start":269,"byte_end":549,"line_start":11,"line_end":17,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"lazy_static! {","highlight_start":1,"highlight_end":15},{"text":"    /// 帧分配器","highlight_start":1,"highlight_end":13},{"text":"    pub static ref FRAME_ALLOCATOR: Mutex<FrameAllocator<AllocatorImpl>> = Mutex::new(FrameAllocator::new(Range::from(","highlight_start":1,"highlight_end":119},{"text":"            PhysicalPageNumber::ceil(*KERNEL_END_ADDRESS)..PhysicalPageNumber::floor(MEMORY_END_ADDRESS),","highlight_start":1,"highlight_end":106},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    ));","highlight_start":1,"highlight_end":8},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"lazy_static!","def_site_span":{"file_name":"/home/saduj/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/lazy_static-1.4.0/src/lib.rs","byte_start":4805,"byte_end":5464,"line_start":167,"line_end":179,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! lazy_static {","highlight_start":1,"highlight_end":27},{"text":"    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":78},{"text":"        // use `()` to explicitly forward the information about private items","highlight_start":1,"highlight_end":78},{"text":"        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":82},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":82},{"text":"        __lazy_static_internal!($(#[$attr])* (pub) static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":85},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ($(#[$attr:meta])* pub ($($vis:tt)+) static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":96},{"text":"        __lazy_static_internal!($(#[$attr])* (pub ($($vis)+)) static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":96},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    () => ()","highlight_start":1,"highlight_end":13},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/main.rs","byte_start":1833,"byte_end":1837,"line_start":69,"line_end":69,"column_start":60,"column_end":64,"is_primary":true,"text":[{"text":"        let frame_0 = match memory::frame::FRAME_ALLOCATOR.lock().alloc() {","highlight_start":60,"highlight_end":64}],"label":"method not found in `memory::frame::allocator::FRAME_ALLOCATOR`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `lock` found for struct `memory::frame::allocator::FRAME_ALLOCATOR` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:69:60\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m69\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        let frame_0 = match memory::frame::FRAME_ALLOCATOR.lock().alloc() {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `memory::frame::allocator::FRAME_ALLOCATOR`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/memory/frame/allocator.rs:11:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mlazy_static! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// 帧分配器\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub static ref FRAME_ALLOCATOR: Mutex<FrameAllocator<AllocatorImpl>> = Mutex::new(FrameAllocator::new(Range::from(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            PhysicalPageNumber::ceil(*KERNEL_END_ADDRESS)..PhysicalPageNumber::floor(MEMORY_END_ADDRESS),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        )\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ));\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `lock` not found for this\u001b[0m\n\n"}
{"message":"no method named `lock` found for struct `memory::frame::allocator::FRAME_ALLOCATOR` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/saduj/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/lazy_static-1.4.0/src/lib.rs","byte_start":4662,"byte_end":5208,"line_start":159,"line_end":173,"column_start":48,"column_end":50,"is_primary":false,"text":[{"text":"        $($vis)* struct $N {__private_field: ()}","highlight_start":48,"highlight_end":49},{"text":"        #[doc(hidden)]","highlight_start":1,"highlight_end":23},{"text":"        $($vis)* static $N: $N = $N {__private_field: ()};","highlight_start":1,"highlight_end":59},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    () => ()","highlight_start":1,"highlight_end":13},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[macro_export(local_inner_macros)]","highlight_start":1,"highlight_end":36},{"text":"macro_rules! lazy_static {","highlight_start":1,"highlight_end":27},{"text":"    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":78},{"text":"        // use `()` to explicitly forward the information about private items","highlight_start":1,"highlight_end":78},{"text":"        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":82},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":82},{"text":"        __lazy_static_internal!($(#[$attr])* (pub) static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":50}],"label":"method `lock` not found for this","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/memory/frame/allocator.rs","byte_start":269,"byte_end":549,"line_start":11,"line_end":17,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"lazy_static! {","highlight_start":1,"highlight_end":15},{"text":"    /// 帧分配器","highlight_start":1,"highlight_end":13},{"text":"    pub static ref FRAME_ALLOCATOR: Mutex<FrameAllocator<AllocatorImpl>> = Mutex::new(FrameAllocator::new(Range::from(","highlight_start":1,"highlight_end":119},{"text":"            PhysicalPageNumber::ceil(*KERNEL_END_ADDRESS)..PhysicalPageNumber::floor(MEMORY_END_ADDRESS),","highlight_start":1,"highlight_end":106},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    ));","highlight_start":1,"highlight_end":8},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"lazy_static!","def_site_span":{"file_name":"/home/saduj/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/lazy_static-1.4.0/src/lib.rs","byte_start":4805,"byte_end":5464,"line_start":167,"line_end":179,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! lazy_static {","highlight_start":1,"highlight_end":27},{"text":"    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":78},{"text":"        // use `()` to explicitly forward the information about private items","highlight_start":1,"highlight_end":78},{"text":"        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":82},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":82},{"text":"        __lazy_static_internal!($(#[$attr])* (pub) static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":85},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ($(#[$attr:meta])* pub ($($vis:tt)+) static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":96},{"text":"        __lazy_static_internal!($(#[$attr])* (pub ($($vis)+)) static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":96},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    () => ()","highlight_start":1,"highlight_end":13},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/main.rs","byte_start":2027,"byte_end":2031,"line_start":73,"line_end":73,"column_start":60,"column_end":64,"is_primary":true,"text":[{"text":"        let frame_1 = match memory::frame::FRAME_ALLOCATOR.lock().alloc() {","highlight_start":60,"highlight_end":64}],"label":"method not found in `memory::frame::allocator::FRAME_ALLOCATOR`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `lock` found for struct `memory::frame::allocator::FRAME_ALLOCATOR` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:73:60\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        let frame_1 = match memory::frame::FRAME_ALLOCATOR.lock().alloc() {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `memory::frame::allocator::FRAME_ALLOCATOR`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/memory/frame/allocator.rs:11:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mlazy_static! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// 帧分配器\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub static ref FRAME_ALLOCATOR: Mutex<FrameAllocator<AllocatorImpl>> = Mutex::new(FrameAllocator::new(Range::from(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            PhysicalPageNumber::ceil(*KERNEL_END_ADDRESS)..PhysicalPageNumber::floor(MEMORY_END_ADDRESS),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        )\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ));\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `lock` not found for this\u001b[0m\n\n"}
{"message":"no method named `lock` found for struct `memory::frame::allocator::FRAME_ALLOCATOR` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/saduj/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/lazy_static-1.4.0/src/lib.rs","byte_start":4662,"byte_end":5208,"line_start":159,"line_end":173,"column_start":48,"column_end":50,"is_primary":false,"text":[{"text":"        $($vis)* struct $N {__private_field: ()}","highlight_start":48,"highlight_end":49},{"text":"        #[doc(hidden)]","highlight_start":1,"highlight_end":23},{"text":"        $($vis)* static $N: $N = $N {__private_field: ()};","highlight_start":1,"highlight_end":59},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    () => ()","highlight_start":1,"highlight_end":13},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[macro_export(local_inner_macros)]","highlight_start":1,"highlight_end":36},{"text":"macro_rules! lazy_static {","highlight_start":1,"highlight_end":27},{"text":"    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":78},{"text":"        // use `()` to explicitly forward the information about private items","highlight_start":1,"highlight_end":78},{"text":"        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":82},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":82},{"text":"        __lazy_static_internal!($(#[$attr])* (pub) static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":50}],"label":"method `lock` not found for this","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/memory/frame/allocator.rs","byte_start":269,"byte_end":549,"line_start":11,"line_end":17,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"lazy_static! {","highlight_start":1,"highlight_end":15},{"text":"    /// 帧分配器","highlight_start":1,"highlight_end":13},{"text":"    pub static ref FRAME_ALLOCATOR: Mutex<FrameAllocator<AllocatorImpl>> = Mutex::new(FrameAllocator::new(Range::from(","highlight_start":1,"highlight_end":119},{"text":"            PhysicalPageNumber::ceil(*KERNEL_END_ADDRESS)..PhysicalPageNumber::floor(MEMORY_END_ADDRESS),","highlight_start":1,"highlight_end":106},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    ));","highlight_start":1,"highlight_end":8},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"lazy_static!","def_site_span":{"file_name":"/home/saduj/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/lazy_static-1.4.0/src/lib.rs","byte_start":4805,"byte_end":5464,"line_start":167,"line_end":179,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! lazy_static {","highlight_start":1,"highlight_end":27},{"text":"    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":78},{"text":"        // use `()` to explicitly forward the information about private items","highlight_start":1,"highlight_end":78},{"text":"        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":82},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":82},{"text":"        __lazy_static_internal!($(#[$attr])* (pub) static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":85},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ($(#[$attr:meta])* pub ($($vis:tt)+) static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {","highlight_start":1,"highlight_end":96},{"text":"        __lazy_static_internal!($(#[$attr])* (pub ($($vis)+)) static ref $N : $T = $e; $($t)*);","highlight_start":1,"highlight_end":96},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    () => ()","highlight_start":1,"highlight_end":13},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/memory/frame/frame_tracker.rs","byte_start":1642,"byte_end":1646,"line_start":38,"line_end":38,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"        FRAME_ALLOCATOR.lock().dealloc(self);","highlight_start":25,"highlight_end":29}],"label":"method not found in `memory::frame::allocator::FRAME_ALLOCATOR`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `lock` found for struct `memory::frame::allocator::FRAME_ALLOCATOR` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/memory/frame/frame_tracker.rs:38:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        FRAME_ALLOCATOR.lock().dealloc(self);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `memory::frame::allocator::FRAME_ALLOCATOR`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/memory/frame/allocator.rs:11:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mlazy_static! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// 帧分配器\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub static ref FRAME_ALLOCATOR: Mutex<FrameAllocator<AllocatorImpl>> = Mutex::new(FrameAllocator::new(Range::from(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            PhysicalPageNumber::ceil(*KERNEL_END_ADDRESS)..PhysicalPageNumber::floor(MEMORY_END_ADDRESS),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        )\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ));\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `lock` not found for this\u001b[0m\n\n"}
{"message":"aborting due to 4 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 4 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0432, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0432, E0599.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0432`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0432`.\u001b[0m\n"}
